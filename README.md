# vdb

Toy implementation of [Vamana (DiskANN) paper](https://proceedings.neurips.cc/paper/2019/file/09853c7fb1d3f8ee67a61b6bf4a7f8e6-Paper.pdf) in Rust

## Plotted Graphs

Here are the 2D vector plots generated by this Vamana implementation:

- degree_bound = 3
- r (initial connections) = 2
- dataset size = 200

The blue points is the top 3 results from trying to `greedy_search(1000.0,1000.0)` on each respective graph. We can that it yielded accurate results after the first pass.

<img src="static/graph-initial.png" alt="Initial Graph" width="50%">

<img src="static/graph-1.png" alt="First Pass, α=1" width="50%">

<img src="static/graph-2.png" alt="Second Pass, α=2" width="50%">

## Storage backends benchmarks

|  Storage  |  greedy_search()     |  index()   |
|  ---  |  ---  |  ---  |
|  In-mem     |       |       |
|  Naive disk   |       |       |
|  io_uring     |       |       |



## Objective of project

1. Deep dive into vector dbs
2. Get more Rust practice
3. Understand Vamana index and disk storage of index
4. Try out benchmarking, see [qdrant](https://qdrant.tech/benchmarks/)
5. Explore if possible to try out io_uring

## TODO

- Try out io_uring experiments?
- Implement insert/delete based on Fresh-DiskANN
- Arbitrary vector dimension
- Dig into <https://github.com/infrawhispers/anansi>
  - How is RocksDB used?
- qdrant benchmarking

## Questions

- In-mem component shouldn't have all the data. What happens if we need to access data in disk while we're operating on the disk files? Is there a lock
  - Can reference LSM tree
  
## Done

[x] Explore disk storage representation
[x] Read Fresh-DiskANN, Filtered-DiskANN

### Experiment 1: Load everything in-memory

1. Measure RAM usage
2. Measure greedy_search latency
